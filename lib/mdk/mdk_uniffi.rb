# This file was autogenerated by some hot garbage in the `uniffi` crate.
# Trust me, you don't want to mess with it!

# Common helper code.
#
# Ideally this would live in a separate .rb file where it can be unittested etc
# in isolation, and perhaps even published as a re-useable package.
#
# However, it's important that the details of how this helper code works (e.g. the
# way that different builtin types are passed across the FFI) exactly match what's
# expected by the rust code on the other side of the interface. In practice right
# now that means coming from the exact some version of `uniffi` that was used to
# compile the rust component. The easiest way to ensure this is to bundle the Ruby
# helpers directly inline like we're doing here.

require 'ffi'


module MdkUniffi
  def self.uniffi_in_range(i, type_name, min, max)
  raise TypeError, "no implicit conversion of #{i} into Integer" unless i.respond_to?(:to_int)
  i = i.to_int
  raise RangeError, "#{type_name} requires #{min} <= value < #{max}" unless (min <= i && i < max)
  i
end

def self.uniffi_utf8(v)
  raise TypeError, "no implicit conversion of #{v} into String" unless v.respond_to?(:to_str)
  v = v.to_str.encode(Encoding::UTF_8)
  raise Encoding::InvalidByteSequenceError, "not a valid UTF-8 encoded string" unless v.valid_encoding?
  v
end

def self.uniffi_bytes(v)
  raise TypeError, "no implicit conversion of #{v} into String" unless v.respond_to?(:to_str)
  v.to_str
end

  class RustBuffer < FFI::Struct
  layout :capacity, :uint64,
         :len,      :uint64,
         :data,     :pointer

  def self.alloc(size)
    return MdkUniffi.rust_call(:ffi_mdk_uniffi_rustbuffer_alloc, size)
  end

  def self.reserve(rbuf, additional)
    return MdkUniffi.rust_call(:ffi_mdk_uniffi_rustbuffer_reserve, rbuf, additional)
  end

  def free
    MdkUniffi.rust_call(:ffi_mdk_uniffi_rustbuffer_free, self)
  end

  def capacity
    self[:capacity]
  end

  def len
    self[:len]
  end

  def len=(value)
    self[:len] = value
  end

  def data
    self[:data]
  end

  def to_s
    "RustBuffer(capacity=#{capacity}, len=#{len}, data=#{data.read_bytes len})"
  end

  # The allocated buffer will be automatically freed if an error occurs, ensuring that
  # we don't accidentally leak it.
  def self.allocWithBuilder
    builder = RustBufferBuilder.new

    begin
      yield builder
    rescue => e
      builder.discard
      raise e
    end
  end

  # The RustBuffer will be freed once the context-manager exits, ensuring that we don't
  # leak it even if an error occurs.
  def consumeWithStream
    stream = RustBufferStream.new self

    yield stream

    raise RuntimeError, 'junk data left in buffer after consuming' if stream.remaining != 0
  ensure
    free
  end# The primitive String type.

  def self.allocFromString(value)
    RustBuffer.allocWithBuilder do |builder|
      builder.write value.encode('utf-8')
      return builder.finalize
    end
  end

  def consumeIntoString
    consumeWithStream do |stream|
      return stream.read(stream.remaining).force_encoding(Encoding::UTF_8)
    end
  end

  # The primitive Bytes type.

  def self.allocFromBytes(value)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_Bytes(value)
      return builder.finalize
    end
  end

  def consumeIntoBytes
    consumeWithStream do |stream|
      return stream.readBytes
    end
  end

  # The Record type CreateGroupResult.

  def self.check_lower_TypeCreateGroupResult(v)
    RustBuffer.check_lower_TypeGroup(v.group)
    RustBuffer.check_lower_Sequencestring(v.welcome_rumors_json)
  end

  def self.alloc_from_TypeCreateGroupResult(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeCreateGroupResult(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeCreateGroupResult
    consumeWithStream do |stream|
      return stream.readTypeCreateGroupResult
    end
  end

  # The Record type Group.

  def self.check_lower_TypeGroup(v)
    
    
    
    
    RustBuffer.check_lower_Optionalbytes(v.image_hash)
    RustBuffer.check_lower_Optionalbytes(v.image_key)
    RustBuffer.check_lower_Optionalbytes(v.image_nonce)
    RustBuffer.check_lower_Sequencestring(v.admin_pubkeys)
    RustBuffer.check_lower_Optionalstring(v.last_message_id)
    RustBuffer.check_lower_Optionalu64(v.last_message_at)
    
    
  end

  def self.alloc_from_TypeGroup(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeGroup(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeGroup
    consumeWithStream do |stream|
      return stream.readTypeGroup
    end
  end

  # The Record type GroupDataUpdate.

  def self.check_lower_TypeGroupDataUpdate(v)
    RustBuffer.check_lower_Optionalstring(v.name)
    RustBuffer.check_lower_Optionalstring(v.description)
    RustBuffer.check_lower_OptionalOptionalbytes(v.image_hash)
    RustBuffer.check_lower_OptionalOptionalbytes(v.image_key)
    RustBuffer.check_lower_OptionalOptionalbytes(v.image_nonce)
    RustBuffer.check_lower_OptionalSequencestring(v.relays)
    RustBuffer.check_lower_OptionalSequencestring(v.admins)
  end

  def self.alloc_from_TypeGroupDataUpdate(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeGroupDataUpdate(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeGroupDataUpdate
    consumeWithStream do |stream|
      return stream.readTypeGroupDataUpdate
    end
  end

  # The Record type GroupImageUpload.

  def self.check_lower_TypeGroupImageUpload(v)
    
    
    
    
    
    
    
    
    RustBuffer.check_lower_OptionalTypeImageDimensions(v.dimensions)
    RustBuffer.check_lower_Optionalstring(v.blurhash)
  end

  def self.alloc_from_TypeGroupImageUpload(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeGroupImageUpload(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeGroupImageUpload
    consumeWithStream do |stream|
      return stream.readTypeGroupImageUpload
    end
  end

  # The Record type ImageDimensions.

  def self.check_lower_TypeImageDimensions(v)
    
    
  end

  def self.alloc_from_TypeImageDimensions(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeImageDimensions(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeImageDimensions
    consumeWithStream do |stream|
      return stream.readTypeImageDimensions
    end
  end

  # The Record type KeyPackageResult.

  def self.check_lower_TypeKeyPackageResult(v)
    
    RustBuffer.check_lower_SequenceSequencestring(v.tags)
  end

  def self.alloc_from_TypeKeyPackageResult(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeKeyPackageResult(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeKeyPackageResult
    consumeWithStream do |stream|
      return stream.readTypeKeyPackageResult
    end
  end

  # The Record type Message.

  def self.check_lower_TypeMessage(v)
    
    
    
    
    
    
    
    
    
  end

  def self.alloc_from_TypeMessage(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeMessage(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeMessage
    consumeWithStream do |stream|
      return stream.readTypeMessage
    end
  end

  # The Record type UpdateGroupResult.

  def self.check_lower_TypeUpdateGroupResult(v)
    
    RustBuffer.check_lower_OptionalSequencestring(v.welcome_rumors_json)
    
  end

  def self.alloc_from_TypeUpdateGroupResult(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeUpdateGroupResult(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeUpdateGroupResult
    consumeWithStream do |stream|
      return stream.readTypeUpdateGroupResult
    end
  end

  # The Record type Welcome.

  def self.check_lower_TypeWelcome(v)
    
    
    
    
    
    
    RustBuffer.check_lower_Optionalbytes(v.group_image_hash)
    RustBuffer.check_lower_Optionalbytes(v.group_image_key)
    RustBuffer.check_lower_Optionalbytes(v.group_image_nonce)
    RustBuffer.check_lower_Sequencestring(v.group_admin_pubkeys)
    RustBuffer.check_lower_Sequencestring(v.group_relays)
    
    
    
    
  end

  def self.alloc_from_TypeWelcome(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeWelcome(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeWelcome
    consumeWithStream do |stream|
      return stream.readTypeWelcome
    end
  end

  

  # The Enum type ProcessMessageResult.

  def self.check_lower_TypeProcessMessageResult(v)
    if v.application_message?
        RustBuffer.check_lower_TypeMessage(v.message)
      return
    end
    if v.proposal?
        RustBuffer.check_lower_TypeUpdateGroupResult(v.result)
      return
    end
    if v.external_join_proposal?
        
      return
    end
    if v.commit?
        
      return
    end
    if v.unprocessable?
        
      return
    end
  end

  def self.alloc_from_TypeProcessMessageResult(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeProcessMessageResult(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeProcessMessageResult
    consumeWithStream do |stream|
      return stream.readTypeProcessMessageResult
    end
  end
  

  # The Optional<T> type for u64.

  def self.check_lower_Optionalu64(v)
    if not v.nil?
      
    end
  end

  def self.alloc_from_Optionalu64(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_Optionalu64(v)
      return builder.finalize()
    end
  end

  def consumeIntoOptionalu64
    consumeWithStream do |stream|
      return stream.readOptionalu64
    end
  end

  # The Optional<T> type for string.

  def self.check_lower_Optionalstring(v)
    if not v.nil?
      
    end
  end

  def self.alloc_from_Optionalstring(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_Optionalstring(v)
      return builder.finalize()
    end
  end

  def consumeIntoOptionalstring
    consumeWithStream do |stream|
      return stream.readOptionalstring
    end
  end

  # The Optional<T> type for bytes.

  def self.check_lower_Optionalbytes(v)
    if not v.nil?
      
    end
  end

  def self.alloc_from_Optionalbytes(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_Optionalbytes(v)
      return builder.finalize()
    end
  end

  def consumeIntoOptionalbytes
    consumeWithStream do |stream|
      return stream.readOptionalbytes
    end
  end

  # The Optional<T> type for TypeGroup.

  def self.check_lower_OptionalTypeGroup(v)
    if not v.nil?
      RustBuffer.check_lower_TypeGroup(v)
    end
  end

  def self.alloc_from_OptionalTypeGroup(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_OptionalTypeGroup(v)
      return builder.finalize()
    end
  end

  def consumeIntoOptionalTypeGroup
    consumeWithStream do |stream|
      return stream.readOptionalTypeGroup
    end
  end

  # The Optional<T> type for TypeImageDimensions.

  def self.check_lower_OptionalTypeImageDimensions(v)
    if not v.nil?
      RustBuffer.check_lower_TypeImageDimensions(v)
    end
  end

  def self.alloc_from_OptionalTypeImageDimensions(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_OptionalTypeImageDimensions(v)
      return builder.finalize()
    end
  end

  def consumeIntoOptionalTypeImageDimensions
    consumeWithStream do |stream|
      return stream.readOptionalTypeImageDimensions
    end
  end

  # The Optional<T> type for TypeMessage.

  def self.check_lower_OptionalTypeMessage(v)
    if not v.nil?
      RustBuffer.check_lower_TypeMessage(v)
    end
  end

  def self.alloc_from_OptionalTypeMessage(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_OptionalTypeMessage(v)
      return builder.finalize()
    end
  end

  def consumeIntoOptionalTypeMessage
    consumeWithStream do |stream|
      return stream.readOptionalTypeMessage
    end
  end

  # The Optional<T> type for TypeWelcome.

  def self.check_lower_OptionalTypeWelcome(v)
    if not v.nil?
      RustBuffer.check_lower_TypeWelcome(v)
    end
  end

  def self.alloc_from_OptionalTypeWelcome(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_OptionalTypeWelcome(v)
      return builder.finalize()
    end
  end

  def consumeIntoOptionalTypeWelcome
    consumeWithStream do |stream|
      return stream.readOptionalTypeWelcome
    end
  end

  # The Optional<T> type for Optionalbytes.

  def self.check_lower_OptionalOptionalbytes(v)
    if not v.nil?
      RustBuffer.check_lower_Optionalbytes(v)
    end
  end

  def self.alloc_from_OptionalOptionalbytes(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_OptionalOptionalbytes(v)
      return builder.finalize()
    end
  end

  def consumeIntoOptionalOptionalbytes
    consumeWithStream do |stream|
      return stream.readOptionalOptionalbytes
    end
  end

  # The Optional<T> type for Sequencestring.

  def self.check_lower_OptionalSequencestring(v)
    if not v.nil?
      RustBuffer.check_lower_Sequencestring(v)
    end
  end

  def self.alloc_from_OptionalSequencestring(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_OptionalSequencestring(v)
      return builder.finalize()
    end
  end

  def consumeIntoOptionalSequencestring
    consumeWithStream do |stream|
      return stream.readOptionalSequencestring
    end
  end

  # The Optional<T> type for SequenceSequencestring.

  def self.check_lower_OptionalSequenceSequencestring(v)
    if not v.nil?
      RustBuffer.check_lower_SequenceSequencestring(v)
    end
  end

  def self.alloc_from_OptionalSequenceSequencestring(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_OptionalSequenceSequencestring(v)
      return builder.finalize()
    end
  end

  def consumeIntoOptionalSequenceSequencestring
    consumeWithStream do |stream|
      return stream.readOptionalSequenceSequencestring
    end
  end

  # The Sequence<T> type for string.

  def self.check_lower_Sequencestring(v)
    v.each do |item|
      
    end
  end

  def self.alloc_from_Sequencestring(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_Sequencestring(v)
      return builder.finalize()
    end
  end

  def consumeIntoSequencestring
    consumeWithStream do |stream|
      return stream.readSequencestring
    end
  end

  # The Sequence<T> type for TypeGroup.

  def self.check_lower_SequenceTypeGroup(v)
    v.each do |item|
      RustBuffer.check_lower_TypeGroup(item)
    end
  end

  def self.alloc_from_SequenceTypeGroup(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_SequenceTypeGroup(v)
      return builder.finalize()
    end
  end

  def consumeIntoSequenceTypeGroup
    consumeWithStream do |stream|
      return stream.readSequenceTypeGroup
    end
  end

  # The Sequence<T> type for TypeMessage.

  def self.check_lower_SequenceTypeMessage(v)
    v.each do |item|
      RustBuffer.check_lower_TypeMessage(item)
    end
  end

  def self.alloc_from_SequenceTypeMessage(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_SequenceTypeMessage(v)
      return builder.finalize()
    end
  end

  def consumeIntoSequenceTypeMessage
    consumeWithStream do |stream|
      return stream.readSequenceTypeMessage
    end
  end

  # The Sequence<T> type for TypeWelcome.

  def self.check_lower_SequenceTypeWelcome(v)
    v.each do |item|
      RustBuffer.check_lower_TypeWelcome(item)
    end
  end

  def self.alloc_from_SequenceTypeWelcome(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_SequenceTypeWelcome(v)
      return builder.finalize()
    end
  end

  def consumeIntoSequenceTypeWelcome
    consumeWithStream do |stream|
      return stream.readSequenceTypeWelcome
    end
  end

  # The Sequence<T> type for Sequencestring.

  def self.check_lower_SequenceSequencestring(v)
    v.each do |item|
      RustBuffer.check_lower_Sequencestring(item)
    end
  end

  def self.alloc_from_SequenceSequencestring(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_SequenceSequencestring(v)
      return builder.finalize()
    end
  end

  def consumeIntoSequenceSequencestring
    consumeWithStream do |stream|
      return stream.readSequenceSequencestring
    end
  end

  
end

module UniFFILib
  class ForeignBytes < FFI::Struct
    layout :len,      :int32,
           :data,     :pointer

    def len
      self[:len]
    end

    def data
      self[:data]
    end

    def to_s
      "ForeignBytes(len=#{len}, data=#{data.read_bytes(len)})"
    end
  end
end

private_constant :UniFFILib
  
# Helper for structured reading of values from a RustBuffer.
class RustBufferStream

  def initialize(rbuf)
    @rbuf = rbuf
    @offset = 0
  end

  def remaining
    @rbuf.len - @offset
  end

  def read(size)
    raise InternalError, 'read past end of rust buffer' if @offset + size > @rbuf.len

    data = @rbuf.data.get_bytes @offset, size

    @offset += size

    data
  end

  def readU16
    unpack_from 2, 'S>'
  end

  def readU32
    unpack_from 4, 'L>'
  end

  def readU64
    unpack_from 8, 'Q>'
  end

  def readString
    size = unpack_from 4, 'l>'

    raise InternalError, 'Unexpected negative string length' if size.negative?

    read(size).force_encoding(Encoding::UTF_8)
  end

  def readBytes
    size = unpack_from 4, 'l>'

    raise InternalError, 'Unexpected negative byte string length' if size.negative?

    read(size).force_encoding(Encoding::BINARY)
  end

  # The Object type Mdk.

  def readTypeMdk
    handle = unpack_from 8, 'Q>'
    return Mdk.uniffi_allocate(handle)
  end

  # The Record type CreateGroupResult.

  def readTypeCreateGroupResult
    CreateGroupResult.new(
      group: readTypeGroup,
      welcome_rumors_json: readSequencestring
    )
  end

  # The Record type Group.

  def readTypeGroup
    Group.new(
      mls_group_id: readString,
      nostr_group_id: readString,
      name: readString,
      description: readString,
      image_hash: readOptionalbytes,
      image_key: readOptionalbytes,
      image_nonce: readOptionalbytes,
      admin_pubkeys: readSequencestring,
      last_message_id: readOptionalstring,
      last_message_at: readOptionalu64,
      epoch: readU64,
      state: readString
    )
  end

  # The Record type GroupDataUpdate.

  def readTypeGroupDataUpdate
    GroupDataUpdate.new(
      name: readOptionalstring,
      description: readOptionalstring,
      image_hash: readOptionalOptionalbytes,
      image_key: readOptionalOptionalbytes,
      image_nonce: readOptionalOptionalbytes,
      relays: readOptionalSequencestring,
      admins: readOptionalSequencestring
    )
  end

  # The Record type GroupImageUpload.

  def readTypeGroupImageUpload
    GroupImageUpload.new(
      encrypted_data: readBytes,
      encrypted_hash: readBytes,
      image_key: readBytes,
      image_nonce: readBytes,
      upload_secret_key: readString,
      original_size: readU64,
      encrypted_size: readU64,
      mime_type: readString,
      dimensions: readOptionalTypeImageDimensions,
      blurhash: readOptionalstring
    )
  end

  # The Record type ImageDimensions.

  def readTypeImageDimensions
    ImageDimensions.new(
      width: readU32,
      height: readU32
    )
  end

  # The Record type KeyPackageResult.

  def readTypeKeyPackageResult
    KeyPackageResult.new(
      key_package: readString,
      tags: readSequenceSequencestring
    )
  end

  # The Record type Message.

  def readTypeMessage
    Message.new(
      id: readString,
      mls_group_id: readString,
      nostr_group_id: readString,
      event_id: readString,
      sender_pubkey: readString,
      event_json: readString,
      processed_at: readU64,
      kind: readU16,
      state: readString
    )
  end

  # The Record type UpdateGroupResult.

  def readTypeUpdateGroupResult
    UpdateGroupResult.new(
      evolution_event_json: readString,
      welcome_rumors_json: readOptionalSequencestring,
      mls_group_id: readString
    )
  end

  # The Record type Welcome.

  def readTypeWelcome
    Welcome.new(
      id: readString,
      event_json: readString,
      mls_group_id: readString,
      nostr_group_id: readString,
      group_name: readString,
      group_description: readString,
      group_image_hash: readOptionalbytes,
      group_image_key: readOptionalbytes,
      group_image_nonce: readOptionalbytes,
      group_admin_pubkeys: readSequencestring,
      group_relays: readSequencestring,
      welcomer: readString,
      member_count: readU32,
      state: readString,
      wrapper_event_id: readString
    )
  end

  

  

  # The Error type MdkUniffiError

  def readTypeMdkUniffiError
    variant = unpack_from 4, 'l>'
    
    if variant == 1
        return MdkUniffiError::Storage.new(
            readString()
        )
    end
    if variant == 2
        return MdkUniffiError::Mdk.new(
            readString()
        )
    end
    if variant == 3
        return MdkUniffiError::InvalidInput.new(
            readString()
        )
    end

    raise InternalError, 'Unexpected variant tag for TypeMdkUniffiError'
  end
  

  
  
  # The Enum type ProcessMessageResult.

  def readTypeProcessMessageResult
    variant = unpack_from 4, 'l>'
    
    if variant == 1
        return ProcessMessageResult::APPLICATION_MESSAGE.new(
            self.readTypeMessage()
        )
    end
    if variant == 2
        return ProcessMessageResult::PROPOSAL.new(
            self.readTypeUpdateGroupResult()
        )
    end
    if variant == 3
        return ProcessMessageResult::EXTERNAL_JOIN_PROPOSAL.new(
            self.readString()
        )
    end
    if variant == 4
        return ProcessMessageResult::COMMIT.new(
            self.readString()
        )
    end
    if variant == 5
        return ProcessMessageResult::UNPROCESSABLE.new(
            self.readString()
        )
    end
    raise InternalError, 'Unexpected variant tag for TypeProcessMessageResult'
  end

  

  # The Optional<T> type for u64.

  def readOptionalu64
    flag = unpack_from 1, 'c'

    if flag == 0
      return nil
    elsif flag == 1
      return readU64
    else
      raise InternalError, 'Unexpected flag byte for Optionalu64'
    end
  end

  # The Optional<T> type for string.

  def readOptionalstring
    flag = unpack_from 1, 'c'

    if flag == 0
      return nil
    elsif flag == 1
      return readString
    else
      raise InternalError, 'Unexpected flag byte for Optionalstring'
    end
  end

  # The Optional<T> type for bytes.

  def readOptionalbytes
    flag = unpack_from 1, 'c'

    if flag == 0
      return nil
    elsif flag == 1
      return readBytes
    else
      raise InternalError, 'Unexpected flag byte for Optionalbytes'
    end
  end

  # The Optional<T> type for TypeGroup.

  def readOptionalTypeGroup
    flag = unpack_from 1, 'c'

    if flag == 0
      return nil
    elsif flag == 1
      return readTypeGroup
    else
      raise InternalError, 'Unexpected flag byte for OptionalTypeGroup'
    end
  end

  # The Optional<T> type for TypeImageDimensions.

  def readOptionalTypeImageDimensions
    flag = unpack_from 1, 'c'

    if flag == 0
      return nil
    elsif flag == 1
      return readTypeImageDimensions
    else
      raise InternalError, 'Unexpected flag byte for OptionalTypeImageDimensions'
    end
  end

  # The Optional<T> type for TypeMessage.

  def readOptionalTypeMessage
    flag = unpack_from 1, 'c'

    if flag == 0
      return nil
    elsif flag == 1
      return readTypeMessage
    else
      raise InternalError, 'Unexpected flag byte for OptionalTypeMessage'
    end
  end

  # The Optional<T> type for TypeWelcome.

  def readOptionalTypeWelcome
    flag = unpack_from 1, 'c'

    if flag == 0
      return nil
    elsif flag == 1
      return readTypeWelcome
    else
      raise InternalError, 'Unexpected flag byte for OptionalTypeWelcome'
    end
  end

  # The Optional<T> type for Optionalbytes.

  def readOptionalOptionalbytes
    flag = unpack_from 1, 'c'

    if flag == 0
      return nil
    elsif flag == 1
      return readOptionalbytes
    else
      raise InternalError, 'Unexpected flag byte for OptionalOptionalbytes'
    end
  end

  # The Optional<T> type for Sequencestring.

  def readOptionalSequencestring
    flag = unpack_from 1, 'c'

    if flag == 0
      return nil
    elsif flag == 1
      return readSequencestring
    else
      raise InternalError, 'Unexpected flag byte for OptionalSequencestring'
    end
  end

  # The Optional<T> type for SequenceSequencestring.

  def readOptionalSequenceSequencestring
    flag = unpack_from 1, 'c'

    if flag == 0
      return nil
    elsif flag == 1
      return readSequenceSequencestring
    else
      raise InternalError, 'Unexpected flag byte for OptionalSequenceSequencestring'
    end
  end

  # The Sequence<T> type for string.

  def readSequencestring
    count = unpack_from 4, 'l>'

    raise InternalError, 'Unexpected negative sequence length' if count.negative?

    items = []

    count.times do
      items.append readString
    end

    items
  end

  # The Sequence<T> type for TypeGroup.

  def readSequenceTypeGroup
    count = unpack_from 4, 'l>'

    raise InternalError, 'Unexpected negative sequence length' if count.negative?

    items = []

    count.times do
      items.append readTypeGroup
    end

    items
  end

  # The Sequence<T> type for TypeMessage.

  def readSequenceTypeMessage
    count = unpack_from 4, 'l>'

    raise InternalError, 'Unexpected negative sequence length' if count.negative?

    items = []

    count.times do
      items.append readTypeMessage
    end

    items
  end

  # The Sequence<T> type for TypeWelcome.

  def readSequenceTypeWelcome
    count = unpack_from 4, 'l>'

    raise InternalError, 'Unexpected negative sequence length' if count.negative?

    items = []

    count.times do
      items.append readTypeWelcome
    end

    items
  end

  # The Sequence<T> type for Sequencestring.

  def readSequenceSequencestring
    count = unpack_from 4, 'l>'

    raise InternalError, 'Unexpected negative sequence length' if count.negative?

    items = []

    count.times do
      items.append readSequencestring
    end

    items
  end

  

  def unpack_from(size, format)
    raise InternalError, 'read past end of rust buffer' if @offset + size > @rbuf.len

    value = @rbuf.data.get_bytes(@offset, size).unpack format

    @offset += size

    # TODO: verify this
    raise 'more than one element!!!' if value.size > 1

    value[0]
  end
end

private_constant :RustBufferStream
  
# Helper for structured writing of values into a RustBuffer.
class RustBufferBuilder
  def initialize
    @rust_buf = RustBuffer.alloc 16
    @rust_buf.len = 0
  end

  def finalize
    rbuf = @rust_buf

    @rust_buf = nil

    rbuf
  end

  def discard
    return if @rust_buf.nil?

    rbuf = finalize
    rbuf.free
  end

  def write(value)
    reserve(value.bytes.size) do
      @rust_buf.data.put_array_of_char @rust_buf.len, value.bytes
    end
  end

  def write_U16(v)
    v = MdkUniffi::uniffi_in_range(v, "u16", 0, 2**16)
    pack_into(2, 'S>', v)
  end

  def write_U32(v)
    v = MdkUniffi::uniffi_in_range(v, "u32", 0, 2**32)
    pack_into(4, 'L>', v)
  end

  def write_U64(v)
    v = MdkUniffi::uniffi_in_range(v, "u64", 0, 2**64)
    pack_into(8, 'Q>', v)
  end

  def write_String(v)
    v = MdkUniffi::uniffi_utf8(v)
    pack_into 4, 'l>', v.bytes.size
    write v
  end

  def write_Bytes(v)
    v = MdkUniffi::uniffi_bytes(v)
    pack_into 4, 'l>', v.bytes.size
    write v
  end

  # The Object type Mdk.

  def write_TypeMdk(obj)
    handle = Mdk.uniffi_lower obj
    pack_into(8, 'Q>', handle)
  end

  # The Record type CreateGroupResult.

  def write_TypeCreateGroupResult(v)
    self.write_TypeGroup(v.group)
    self.write_Sequencestring(v.welcome_rumors_json)
  end

  # The Record type Group.

  def write_TypeGroup(v)
    self.write_String(v.mls_group_id)
    self.write_String(v.nostr_group_id)
    self.write_String(v.name)
    self.write_String(v.description)
    self.write_Optionalbytes(v.image_hash)
    self.write_Optionalbytes(v.image_key)
    self.write_Optionalbytes(v.image_nonce)
    self.write_Sequencestring(v.admin_pubkeys)
    self.write_Optionalstring(v.last_message_id)
    self.write_Optionalu64(v.last_message_at)
    self.write_U64(v.epoch)
    self.write_String(v.state)
  end

  # The Record type GroupDataUpdate.

  def write_TypeGroupDataUpdate(v)
    self.write_Optionalstring(v.name)
    self.write_Optionalstring(v.description)
    self.write_OptionalOptionalbytes(v.image_hash)
    self.write_OptionalOptionalbytes(v.image_key)
    self.write_OptionalOptionalbytes(v.image_nonce)
    self.write_OptionalSequencestring(v.relays)
    self.write_OptionalSequencestring(v.admins)
  end

  # The Record type GroupImageUpload.

  def write_TypeGroupImageUpload(v)
    self.write_Bytes(v.encrypted_data)
    self.write_Bytes(v.encrypted_hash)
    self.write_Bytes(v.image_key)
    self.write_Bytes(v.image_nonce)
    self.write_String(v.upload_secret_key)
    self.write_U64(v.original_size)
    self.write_U64(v.encrypted_size)
    self.write_String(v.mime_type)
    self.write_OptionalTypeImageDimensions(v.dimensions)
    self.write_Optionalstring(v.blurhash)
  end

  # The Record type ImageDimensions.

  def write_TypeImageDimensions(v)
    self.write_U32(v.width)
    self.write_U32(v.height)
  end

  # The Record type KeyPackageResult.

  def write_TypeKeyPackageResult(v)
    self.write_String(v.key_package)
    self.write_SequenceSequencestring(v.tags)
  end

  # The Record type Message.

  def write_TypeMessage(v)
    self.write_String(v.id)
    self.write_String(v.mls_group_id)
    self.write_String(v.nostr_group_id)
    self.write_String(v.event_id)
    self.write_String(v.sender_pubkey)
    self.write_String(v.event_json)
    self.write_U64(v.processed_at)
    self.write_U16(v.kind)
    self.write_String(v.state)
  end

  # The Record type UpdateGroupResult.

  def write_TypeUpdateGroupResult(v)
    self.write_String(v.evolution_event_json)
    self.write_OptionalSequencestring(v.welcome_rumors_json)
    self.write_String(v.mls_group_id)
  end

  # The Record type Welcome.

  def write_TypeWelcome(v)
    self.write_String(v.id)
    self.write_String(v.event_json)
    self.write_String(v.mls_group_id)
    self.write_String(v.nostr_group_id)
    self.write_String(v.group_name)
    self.write_String(v.group_description)
    self.write_Optionalbytes(v.group_image_hash)
    self.write_Optionalbytes(v.group_image_key)
    self.write_Optionalbytes(v.group_image_nonce)
    self.write_Sequencestring(v.group_admin_pubkeys)
    self.write_Sequencestring(v.group_relays)
    self.write_String(v.welcomer)
    self.write_U32(v.member_count)
    self.write_String(v.state)
    self.write_String(v.wrapper_event_id)
  end

  

  # The Enum type ProcessMessageResult.

  def write_TypeProcessMessageResult(v)
    if v.application_message?
      pack_into(4, 'l>', 1)
      self.write_TypeMessage(v.message)
    end
    if v.proposal?
      pack_into(4, 'l>', 2)
      self.write_TypeUpdateGroupResult(v.result)
    end
    if v.external_join_proposal?
      pack_into(4, 'l>', 3)
      self.write_String(v.mls_group_id)
    end
    if v.commit?
      pack_into(4, 'l>', 4)
      self.write_String(v.mls_group_id)
    end
    if v.unprocessable?
      pack_into(4, 'l>', 5)
      self.write_String(v.mls_group_id)
    end
 end
   

  # The Optional<T> type for u64.

  def write_Optionalu64(v)
    if v.nil?
      pack_into(1, 'c', 0)
    else
      pack_into(1, 'c', 1)
      self.write_U64(v)
    end
  end

  # The Optional<T> type for string.

  def write_Optionalstring(v)
    if v.nil?
      pack_into(1, 'c', 0)
    else
      pack_into(1, 'c', 1)
      self.write_String(v)
    end
  end

  # The Optional<T> type for bytes.

  def write_Optionalbytes(v)
    if v.nil?
      pack_into(1, 'c', 0)
    else
      pack_into(1, 'c', 1)
      self.write_Bytes(v)
    end
  end

  # The Optional<T> type for TypeGroup.

  def write_OptionalTypeGroup(v)
    if v.nil?
      pack_into(1, 'c', 0)
    else
      pack_into(1, 'c', 1)
      self.write_TypeGroup(v)
    end
  end

  # The Optional<T> type for TypeImageDimensions.

  def write_OptionalTypeImageDimensions(v)
    if v.nil?
      pack_into(1, 'c', 0)
    else
      pack_into(1, 'c', 1)
      self.write_TypeImageDimensions(v)
    end
  end

  # The Optional<T> type for TypeMessage.

  def write_OptionalTypeMessage(v)
    if v.nil?
      pack_into(1, 'c', 0)
    else
      pack_into(1, 'c', 1)
      self.write_TypeMessage(v)
    end
  end

  # The Optional<T> type for TypeWelcome.

  def write_OptionalTypeWelcome(v)
    if v.nil?
      pack_into(1, 'c', 0)
    else
      pack_into(1, 'c', 1)
      self.write_TypeWelcome(v)
    end
  end

  # The Optional<T> type for Optionalbytes.

  def write_OptionalOptionalbytes(v)
    if v.nil?
      pack_into(1, 'c', 0)
    else
      pack_into(1, 'c', 1)
      self.write_Optionalbytes(v)
    end
  end

  # The Optional<T> type for Sequencestring.

  def write_OptionalSequencestring(v)
    if v.nil?
      pack_into(1, 'c', 0)
    else
      pack_into(1, 'c', 1)
      self.write_Sequencestring(v)
    end
  end

  # The Optional<T> type for SequenceSequencestring.

  def write_OptionalSequenceSequencestring(v)
    if v.nil?
      pack_into(1, 'c', 0)
    else
      pack_into(1, 'c', 1)
      self.write_SequenceSequencestring(v)
    end
  end

  # The Sequence<T> type for string.

  def write_Sequencestring(items)
    pack_into(4, 'l>', items.size)

    items.each do |item|
      self.write_String(item)
    end
  end

  # The Sequence<T> type for TypeGroup.

  def write_SequenceTypeGroup(items)
    pack_into(4, 'l>', items.size)

    items.each do |item|
      self.write_TypeGroup(item)
    end
  end

  # The Sequence<T> type for TypeMessage.

  def write_SequenceTypeMessage(items)
    pack_into(4, 'l>', items.size)

    items.each do |item|
      self.write_TypeMessage(item)
    end
  end

  # The Sequence<T> type for TypeWelcome.

  def write_SequenceTypeWelcome(items)
    pack_into(4, 'l>', items.size)

    items.each do |item|
      self.write_TypeWelcome(item)
    end
  end

  # The Sequence<T> type for Sequencestring.

  def write_SequenceSequencestring(items)
    pack_into(4, 'l>', items.size)

    items.each do |item|
      self.write_Sequencestring(item)
    end
  end

  

  private

  def reserve(num_bytes)
    if @rust_buf.len + num_bytes > @rust_buf.capacity
      @rust_buf = RustBuffer.reserve(@rust_buf, num_bytes)
    end

    yield

    @rust_buf.len += num_bytes
  end

  def pack_into(size, format, value)
    reserve(size) do
      @rust_buf.data.put_array_of_char @rust_buf.len, [value].pack(format).bytes
    end
  end
end

private_constant :RustBufferBuilder

  # Error definitions
  class RustCallStatus < FFI::Struct
  layout :code,    :int8,
         :error_buf, RustBuffer

  def code
    self[:code]
  end

  def error_buf
    self[:error_buf]
  end

  def to_s
    "RustCallStatus(code=#{self[:code]})"
  end
end

# These match the values from the uniffi::rustcalls module
CALL_SUCCESS = 0
CALL_ERROR = 1
CALL_PANIC = 2


module MdkUniffiError
  class Storage < StandardError
    def initialize()
        @ = 
        super()
      end

    attr_reader :
    

    def to_s
     "#{self.class.name}(=#{@.inspect})"
    end
  end
  class Mdk < StandardError
    def initialize()
        @ = 
        super()
      end

    attr_reader :
    

    def to_s
     "#{self.class.name}(=#{@.inspect})"
    end
  end
  class InvalidInput < StandardError
    def initialize()
        @ = 
        super()
      end

    attr_reader :
    

    def to_s
     "#{self.class.name}(=#{@.inspect})"
    end
  end

end



# Map error modules to the RustBuffer method name that reads them
ERROR_MODULE_TO_READER_METHOD = {

  MdkUniffiError => :readTypeMdkUniffiError,


}

private_constant :ERROR_MODULE_TO_READER_METHOD, :CALL_SUCCESS, :CALL_ERROR, :CALL_PANIC,
                 :RustCallStatus

def self.consume_buffer_into_error(error_module, rust_buffer)
  rust_buffer.consumeWithStream do |stream|
    reader_method = ERROR_MODULE_TO_READER_METHOD[error_module]
    return stream.send(reader_method)
  end
end

class InternalError < StandardError
end

def self.rust_call(fn_name, *args)
  # Call a rust function
  rust_call_with_error(nil, fn_name, *args)
end

def self.rust_call_with_error(error_module, fn_name, *args)
  # Call a rust function and handle errors
  #
  # Use this when the rust function returns a Result<>.  error_module must be the error_module that corresponds to that Result.


  # Note: RustCallStatus.new zeroes out the struct, which is exactly what we
  # want to pass to Rust (code=0, error_buf=RustBuffer(len=0, capacity=0,
  # data=NULL))
  status = RustCallStatus.new
  args << status

  result = UniFFILib.public_send(fn_name, *args)

  case status.code
  when CALL_SUCCESS
    result
  when CALL_ERROR
    if error_module.nil?
      status.error_buf.free
      raise InternalError, "CALL_ERROR with no error_module set"
    else
      raise consume_buffer_into_error(error_module, status.error_buf)
    end
  when CALL_PANIC
    # When the rust code sees a panic, it tries to construct a RustBuffer
    # with the message.  But if that code panics, then it just sends back
    # an empty buffer.
    if status.error_buf.len > 0
      raise InternalError, status.error_buf.consumeIntoString()
    else
      raise InternalError, "Rust panic"
    end
  else
    raise InternalError, "Unknown call status: #{status.code}"
  end
end

private_class_method :consume_buffer_into_error

  # This is how we find and load the dynamic library provided by the component.
# For now we just look it up by name.
module UniFFILib
  extend FFI::Library

  
  ffi_lib 'mdk_uniffi'
  

  attach_function :uniffi_mdk_uniffi_fn_clone_mdk,
    [:uint64, RustCallStatus.by_ref],
    :uint64
  attach_function :uniffi_mdk_uniffi_fn_free_mdk,
    [:uint64, RustCallStatus.by_ref],
    :void
  attach_function :uniffi_mdk_uniffi_fn_method_mdk_accept_welcome,
    [:uint64, RustBuffer.by_value, RustCallStatus.by_ref],
    :void
  attach_function :uniffi_mdk_uniffi_fn_method_mdk_accept_welcome_json,
    [:uint64, RustBuffer.by_value, RustCallStatus.by_ref],
    :void
  attach_function :uniffi_mdk_uniffi_fn_method_mdk_add_members,
    [:uint64, RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_mdk_uniffi_fn_method_mdk_create_group,
    [:uint64, RustBuffer.by_value, RustBuffer.by_value, RustBuffer.by_value, RustBuffer.by_value, RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_mdk_uniffi_fn_method_mdk_create_key_package_for_event,
    [:uint64, RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_mdk_uniffi_fn_method_mdk_create_message,
    [:uint64, RustBuffer.by_value, RustBuffer.by_value, RustBuffer.by_value, :uint16, RustBuffer.by_value, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_mdk_uniffi_fn_method_mdk_decline_welcome,
    [:uint64, RustBuffer.by_value, RustCallStatus.by_ref],
    :void
  attach_function :uniffi_mdk_uniffi_fn_method_mdk_decline_welcome_json,
    [:uint64, RustBuffer.by_value, RustCallStatus.by_ref],
    :void
  attach_function :uniffi_mdk_uniffi_fn_method_mdk_get_group,
    [:uint64, RustBuffer.by_value, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_mdk_uniffi_fn_method_mdk_get_groups,
    [:uint64, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_mdk_uniffi_fn_method_mdk_get_members,
    [:uint64, RustBuffer.by_value, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_mdk_uniffi_fn_method_mdk_get_message,
    [:uint64, RustBuffer.by_value, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_mdk_uniffi_fn_method_mdk_get_messages,
    [:uint64, RustBuffer.by_value, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_mdk_uniffi_fn_method_mdk_get_pending_welcomes,
    [:uint64, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_mdk_uniffi_fn_method_mdk_get_relays,
    [:uint64, RustBuffer.by_value, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_mdk_uniffi_fn_method_mdk_get_welcome,
    [:uint64, RustBuffer.by_value, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_mdk_uniffi_fn_method_mdk_leave_group,
    [:uint64, RustBuffer.by_value, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_mdk_uniffi_fn_method_mdk_merge_pending_commit,
    [:uint64, RustBuffer.by_value, RustCallStatus.by_ref],
    :void
  attach_function :uniffi_mdk_uniffi_fn_method_mdk_parse_key_package,
    [:uint64, RustBuffer.by_value, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_mdk_uniffi_fn_method_mdk_process_message,
    [:uint64, RustBuffer.by_value, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_mdk_uniffi_fn_method_mdk_process_welcome,
    [:uint64, RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_mdk_uniffi_fn_method_mdk_remove_members,
    [:uint64, RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_mdk_uniffi_fn_method_mdk_self_update,
    [:uint64, RustBuffer.by_value, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_mdk_uniffi_fn_method_mdk_sync_group_metadata_from_mls,
    [:uint64, RustBuffer.by_value, RustCallStatus.by_ref],
    :void
  attach_function :uniffi_mdk_uniffi_fn_method_mdk_update_group_data,
    [:uint64, RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_mdk_uniffi_fn_func_decrypt_group_image,
    [RustBuffer.by_value, RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_mdk_uniffi_fn_func_derive_upload_keypair,
    [RustBuffer.by_value, :uint16, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_mdk_uniffi_fn_func_new_mdk,
    [RustBuffer.by_value, RustCallStatus.by_ref],
    :uint64
  attach_function :uniffi_mdk_uniffi_fn_func_prepare_group_image_for_upload,
    [RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_mdk_uniffi_rustbuffer_alloc,
    [:uint64, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_mdk_uniffi_rustbuffer_from_bytes,
    [ForeignBytes, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_mdk_uniffi_rustbuffer_free,
    [RustBuffer.by_value, RustCallStatus.by_ref],
    :void
  attach_function :ffi_mdk_uniffi_rustbuffer_reserve,
    [RustBuffer.by_value, :uint64, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_mdk_uniffi_checksum_func_decrypt_group_image,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_mdk_uniffi_checksum_func_derive_upload_keypair,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_mdk_uniffi_checksum_func_new_mdk,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_mdk_uniffi_checksum_func_prepare_group_image_for_upload,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_mdk_uniffi_checksum_method_mdk_accept_welcome,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_mdk_uniffi_checksum_method_mdk_accept_welcome_json,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_mdk_uniffi_checksum_method_mdk_add_members,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_mdk_uniffi_checksum_method_mdk_create_group,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_mdk_uniffi_checksum_method_mdk_create_key_package_for_event,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_mdk_uniffi_checksum_method_mdk_create_message,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_mdk_uniffi_checksum_method_mdk_decline_welcome,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_mdk_uniffi_checksum_method_mdk_decline_welcome_json,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_mdk_uniffi_checksum_method_mdk_get_group,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_mdk_uniffi_checksum_method_mdk_get_groups,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_mdk_uniffi_checksum_method_mdk_get_members,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_mdk_uniffi_checksum_method_mdk_get_message,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_mdk_uniffi_checksum_method_mdk_get_messages,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_mdk_uniffi_checksum_method_mdk_get_pending_welcomes,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_mdk_uniffi_checksum_method_mdk_get_relays,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_mdk_uniffi_checksum_method_mdk_get_welcome,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_mdk_uniffi_checksum_method_mdk_leave_group,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_mdk_uniffi_checksum_method_mdk_merge_pending_commit,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_mdk_uniffi_checksum_method_mdk_parse_key_package,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_mdk_uniffi_checksum_method_mdk_process_message,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_mdk_uniffi_checksum_method_mdk_process_welcome,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_mdk_uniffi_checksum_method_mdk_remove_members,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_mdk_uniffi_checksum_method_mdk_self_update,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_mdk_uniffi_checksum_method_mdk_sync_group_metadata_from_mls,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_mdk_uniffi_checksum_method_mdk_update_group_data,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :ffi_mdk_uniffi_uniffi_contract_version,
    [RustCallStatus.by_ref],
    :uint32
  
end

  # Public interface members begin here.

  
  
  
  

class ProcessMessageResult
  def initialize
    raise RuntimeError, 'ProcessMessageResult cannot be instantiated directly'
  end

  # Each enum variant is a nested class of the enum itself.
  class APPLICATION_MESSAGE
    
    attr_reader :message
    
    def initialize(message)
      
      @message = message
      
    end

    def to_s
      "ProcessMessageResult::APPLICATION_MESSAGE(message=#{@message})"
    end

    def ==(other)
      if !other.application_message?
        return false
      end
      if @message != other.message
        return false
      end

      true
    end

    # For each variant, we have an `NAME?` method for easily checking
    # whether an instance is that variant.
    
    def application_message?
      instance_of? ProcessMessageResult::APPLICATION_MESSAGE
    end
    
    def proposal?
      instance_of? ProcessMessageResult::PROPOSAL
    end
    
    def external_join_proposal?
      instance_of? ProcessMessageResult::EXTERNAL_JOIN_PROPOSAL
    end
    
    def commit?
      instance_of? ProcessMessageResult::COMMIT
    end
    
    def unprocessable?
      instance_of? ProcessMessageResult::UNPROCESSABLE
    end
    
  end
  class PROPOSAL
    
    attr_reader :result
    
    def initialize(result)
      
      @result = result
      
    end

    def to_s
      "ProcessMessageResult::PROPOSAL(result=#{@result})"
    end

    def ==(other)
      if !other.proposal?
        return false
      end
      if @result != other.result
        return false
      end

      true
    end

    # For each variant, we have an `NAME?` method for easily checking
    # whether an instance is that variant.
    
    def application_message?
      instance_of? ProcessMessageResult::APPLICATION_MESSAGE
    end
    
    def proposal?
      instance_of? ProcessMessageResult::PROPOSAL
    end
    
    def external_join_proposal?
      instance_of? ProcessMessageResult::EXTERNAL_JOIN_PROPOSAL
    end
    
    def commit?
      instance_of? ProcessMessageResult::COMMIT
    end
    
    def unprocessable?
      instance_of? ProcessMessageResult::UNPROCESSABLE
    end
    
  end
  class EXTERNAL_JOIN_PROPOSAL
    
    attr_reader :mls_group_id
    
    def initialize(mls_group_id)
      
      @mls_group_id = mls_group_id
      
    end

    def to_s
      "ProcessMessageResult::EXTERNAL_JOIN_PROPOSAL(mls_group_id=#{@mls_group_id})"
    end

    def ==(other)
      if !other.external_join_proposal?
        return false
      end
      if @mls_group_id != other.mls_group_id
        return false
      end

      true
    end

    # For each variant, we have an `NAME?` method for easily checking
    # whether an instance is that variant.
    
    def application_message?
      instance_of? ProcessMessageResult::APPLICATION_MESSAGE
    end
    
    def proposal?
      instance_of? ProcessMessageResult::PROPOSAL
    end
    
    def external_join_proposal?
      instance_of? ProcessMessageResult::EXTERNAL_JOIN_PROPOSAL
    end
    
    def commit?
      instance_of? ProcessMessageResult::COMMIT
    end
    
    def unprocessable?
      instance_of? ProcessMessageResult::UNPROCESSABLE
    end
    
  end
  class COMMIT
    
    attr_reader :mls_group_id
    
    def initialize(mls_group_id)
      
      @mls_group_id = mls_group_id
      
    end

    def to_s
      "ProcessMessageResult::COMMIT(mls_group_id=#{@mls_group_id})"
    end

    def ==(other)
      if !other.commit?
        return false
      end
      if @mls_group_id != other.mls_group_id
        return false
      end

      true
    end

    # For each variant, we have an `NAME?` method for easily checking
    # whether an instance is that variant.
    
    def application_message?
      instance_of? ProcessMessageResult::APPLICATION_MESSAGE
    end
    
    def proposal?
      instance_of? ProcessMessageResult::PROPOSAL
    end
    
    def external_join_proposal?
      instance_of? ProcessMessageResult::EXTERNAL_JOIN_PROPOSAL
    end
    
    def commit?
      instance_of? ProcessMessageResult::COMMIT
    end
    
    def unprocessable?
      instance_of? ProcessMessageResult::UNPROCESSABLE
    end
    
  end
  class UNPROCESSABLE
    
    attr_reader :mls_group_id
    
    def initialize(mls_group_id)
      
      @mls_group_id = mls_group_id
      
    end

    def to_s
      "ProcessMessageResult::UNPROCESSABLE(mls_group_id=#{@mls_group_id})"
    end

    def ==(other)
      if !other.unprocessable?
        return false
      end
      if @mls_group_id != other.mls_group_id
        return false
      end

      true
    end

    # For each variant, we have an `NAME?` method for easily checking
    # whether an instance is that variant.
    
    def application_message?
      instance_of? ProcessMessageResult::APPLICATION_MESSAGE
    end
    
    def proposal?
      instance_of? ProcessMessageResult::PROPOSAL
    end
    
    def external_join_proposal?
      instance_of? ProcessMessageResult::EXTERNAL_JOIN_PROPOSAL
    end
    
    def commit?
      instance_of? ProcessMessageResult::COMMIT
    end
    
    def unprocessable?
      instance_of? ProcessMessageResult::UNPROCESSABLE
    end
    
  end
  
end


  
  # Record type CreateGroupResult
class CreateGroupResult
  attr_reader :group, :welcome_rumors_json

  def initialize(group:, welcome_rumors_json:)
    @group = group
    @welcome_rumors_json = welcome_rumors_json
  end

  def ==(other)
    if @group != other.group
      return false
    end
    if @welcome_rumors_json != other.welcome_rumors_json
      return false
    end

    true
  end
end
  
  # Record type Group
class Group
  attr_reader :mls_group_id, :nostr_group_id, :name, :description, :image_hash, :image_key, :image_nonce, :admin_pubkeys, :last_message_id, :last_message_at, :epoch, :state

  def initialize(mls_group_id:, nostr_group_id:, name:, description:, image_hash:, image_key:, image_nonce:, admin_pubkeys:, last_message_id:, last_message_at:, epoch:, state:)
    @mls_group_id = mls_group_id
    @nostr_group_id = nostr_group_id
    @name = name
    @description = description
    @image_hash = image_hash
    @image_key = image_key
    @image_nonce = image_nonce
    @admin_pubkeys = admin_pubkeys
    @last_message_id = last_message_id
    @last_message_at = last_message_at
    @epoch = epoch
    @state = state
  end

  def ==(other)
    if @mls_group_id != other.mls_group_id
      return false
    end
    if @nostr_group_id != other.nostr_group_id
      return false
    end
    if @name != other.name
      return false
    end
    if @description != other.description
      return false
    end
    if @image_hash != other.image_hash
      return false
    end
    if @image_key != other.image_key
      return false
    end
    if @image_nonce != other.image_nonce
      return false
    end
    if @admin_pubkeys != other.admin_pubkeys
      return false
    end
    if @last_message_id != other.last_message_id
      return false
    end
    if @last_message_at != other.last_message_at
      return false
    end
    if @epoch != other.epoch
      return false
    end
    if @state != other.state
      return false
    end

    true
  end
end
  
  # Record type GroupDataUpdate
class GroupDataUpdate
  attr_reader :name, :description, :image_hash, :image_key, :image_nonce, :relays, :admins

  def initialize(name:, description:, image_hash:, image_key:, image_nonce:, relays:, admins:)
    @name = name
    @description = description
    @image_hash = image_hash
    @image_key = image_key
    @image_nonce = image_nonce
    @relays = relays
    @admins = admins
  end

  def ==(other)
    if @name != other.name
      return false
    end
    if @description != other.description
      return false
    end
    if @image_hash != other.image_hash
      return false
    end
    if @image_key != other.image_key
      return false
    end
    if @image_nonce != other.image_nonce
      return false
    end
    if @relays != other.relays
      return false
    end
    if @admins != other.admins
      return false
    end

    true
  end
end
  
  # Record type GroupImageUpload
class GroupImageUpload
  attr_reader :encrypted_data, :encrypted_hash, :image_key, :image_nonce, :upload_secret_key, :original_size, :encrypted_size, :mime_type, :dimensions, :blurhash

  def initialize(encrypted_data:, encrypted_hash:, image_key:, image_nonce:, upload_secret_key:, original_size:, encrypted_size:, mime_type:, dimensions:, blurhash:)
    @encrypted_data = encrypted_data
    @encrypted_hash = encrypted_hash
    @image_key = image_key
    @image_nonce = image_nonce
    @upload_secret_key = upload_secret_key
    @original_size = original_size
    @encrypted_size = encrypted_size
    @mime_type = mime_type
    @dimensions = dimensions
    @blurhash = blurhash
  end

  def ==(other)
    if @encrypted_data != other.encrypted_data
      return false
    end
    if @encrypted_hash != other.encrypted_hash
      return false
    end
    if @image_key != other.image_key
      return false
    end
    if @image_nonce != other.image_nonce
      return false
    end
    if @upload_secret_key != other.upload_secret_key
      return false
    end
    if @original_size != other.original_size
      return false
    end
    if @encrypted_size != other.encrypted_size
      return false
    end
    if @mime_type != other.mime_type
      return false
    end
    if @dimensions != other.dimensions
      return false
    end
    if @blurhash != other.blurhash
      return false
    end

    true
  end
end
  
  # Record type ImageDimensions
class ImageDimensions
  attr_reader :width, :height

  def initialize(width:, height:)
    @width = width
    @height = height
  end

  def ==(other)
    if @width != other.width
      return false
    end
    if @height != other.height
      return false
    end

    true
  end
end
  
  # Record type KeyPackageResult
class KeyPackageResult
  attr_reader :key_package, :tags

  def initialize(key_package:, tags:)
    @key_package = key_package
    @tags = tags
  end

  def ==(other)
    if @key_package != other.key_package
      return false
    end
    if @tags != other.tags
      return false
    end

    true
  end
end
  
  # Record type Message
class Message
  attr_reader :id, :mls_group_id, :nostr_group_id, :event_id, :sender_pubkey, :event_json, :processed_at, :kind, :state

  def initialize(id:, mls_group_id:, nostr_group_id:, event_id:, sender_pubkey:, event_json:, processed_at:, kind:, state:)
    @id = id
    @mls_group_id = mls_group_id
    @nostr_group_id = nostr_group_id
    @event_id = event_id
    @sender_pubkey = sender_pubkey
    @event_json = event_json
    @processed_at = processed_at
    @kind = kind
    @state = state
  end

  def ==(other)
    if @id != other.id
      return false
    end
    if @mls_group_id != other.mls_group_id
      return false
    end
    if @nostr_group_id != other.nostr_group_id
      return false
    end
    if @event_id != other.event_id
      return false
    end
    if @sender_pubkey != other.sender_pubkey
      return false
    end
    if @event_json != other.event_json
      return false
    end
    if @processed_at != other.processed_at
      return false
    end
    if @kind != other.kind
      return false
    end
    if @state != other.state
      return false
    end

    true
  end
end
  
  # Record type UpdateGroupResult
class UpdateGroupResult
  attr_reader :evolution_event_json, :welcome_rumors_json, :mls_group_id

  def initialize(evolution_event_json:, welcome_rumors_json:, mls_group_id:)
    @evolution_event_json = evolution_event_json
    @welcome_rumors_json = welcome_rumors_json
    @mls_group_id = mls_group_id
  end

  def ==(other)
    if @evolution_event_json != other.evolution_event_json
      return false
    end
    if @welcome_rumors_json != other.welcome_rumors_json
      return false
    end
    if @mls_group_id != other.mls_group_id
      return false
    end

    true
  end
end
  
  # Record type Welcome
class Welcome
  attr_reader :id, :event_json, :mls_group_id, :nostr_group_id, :group_name, :group_description, :group_image_hash, :group_image_key, :group_image_nonce, :group_admin_pubkeys, :group_relays, :welcomer, :member_count, :state, :wrapper_event_id

  def initialize(id:, event_json:, mls_group_id:, nostr_group_id:, group_name:, group_description:, group_image_hash:, group_image_key:, group_image_nonce:, group_admin_pubkeys:, group_relays:, welcomer:, member_count:, state:, wrapper_event_id:)
    @id = id
    @event_json = event_json
    @mls_group_id = mls_group_id
    @nostr_group_id = nostr_group_id
    @group_name = group_name
    @group_description = group_description
    @group_image_hash = group_image_hash
    @group_image_key = group_image_key
    @group_image_nonce = group_image_nonce
    @group_admin_pubkeys = group_admin_pubkeys
    @group_relays = group_relays
    @welcomer = welcomer
    @member_count = member_count
    @state = state
    @wrapper_event_id = wrapper_event_id
  end

  def ==(other)
    if @id != other.id
      return false
    end
    if @event_json != other.event_json
      return false
    end
    if @mls_group_id != other.mls_group_id
      return false
    end
    if @nostr_group_id != other.nostr_group_id
      return false
    end
    if @group_name != other.group_name
      return false
    end
    if @group_description != other.group_description
      return false
    end
    if @group_image_hash != other.group_image_hash
      return false
    end
    if @group_image_key != other.group_image_key
      return false
    end
    if @group_image_nonce != other.group_image_nonce
      return false
    end
    if @group_admin_pubkeys != other.group_admin_pubkeys
      return false
    end
    if @group_relays != other.group_relays
      return false
    end
    if @welcomer != other.welcomer
      return false
    end
    if @member_count != other.member_count
      return false
    end
    if @state != other.state
      return false
    end
    if @wrapper_event_id != other.wrapper_event_id
      return false
    end

    true
  end
end
  

  
  

def self.decrypt_group_image(encrypted_data, image_key, image_nonce)
    encrypted_data = MdkUniffi::uniffi_bytes(encrypted_data)
    
    
    image_key = MdkUniffi::uniffi_bytes(image_key)
    
    
    image_nonce = MdkUniffi::uniffi_bytes(image_nonce)
    
    
  result = MdkUniffi.rust_call_with_error(MdkUniffiError,:uniffi_mdk_uniffi_fn_func_decrypt_group_image,RustBuffer.allocFromBytes(encrypted_data),RustBuffer.allocFromBytes(image_key),RustBuffer.allocFromBytes(image_nonce))
  return result.consumeIntoBytes
end


  
  

def self.derive_upload_keypair(image_key, version)
    image_key = MdkUniffi::uniffi_bytes(image_key)
    
    
    version = MdkUniffi::uniffi_in_range(version, "u16", 0, 2**16)
    
    
  result = MdkUniffi.rust_call_with_error(MdkUniffiError,:uniffi_mdk_uniffi_fn_func_derive_upload_keypair,RustBuffer.allocFromBytes(image_key),version)
  return result.consumeIntoString
end


  
  

def self.new_mdk(db_path)
    db_path = MdkUniffi::uniffi_utf8(db_path)
    
    
  result = MdkUniffi.rust_call_with_error(MdkUniffiError,:uniffi_mdk_uniffi_fn_func_new_mdk,RustBuffer.allocFromString(db_path))
  return Mdk.uniffi_allocate(result)
end


  
  

def self.prepare_group_image_for_upload(image_data, mime_type)
    image_data = MdkUniffi::uniffi_bytes(image_data)
    
    
    mime_type = MdkUniffi::uniffi_utf8(mime_type)
    
    
  result = MdkUniffi.rust_call_with_error(MdkUniffiError,:uniffi_mdk_uniffi_fn_func_prepare_group_image_for_upload,RustBuffer.allocFromBytes(image_data),RustBuffer.allocFromString(mime_type))
  return result.consumeIntoTypeGroupImageUpload
end


  

  
  class Mdk

  # A private helper for initializing instances of the class from a raw handle,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self.uniffi_allocate(handle)
    inst = allocate
    inst.instance_variable_set :@handle, handle
    ObjectSpace.define_finalizer(inst, uniffi_define_finalizer_by_handle(handle, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying handle.
  def self.uniffi_define_finalizer_by_handle(handle, object_id)
    Proc.new do |_id|
      MdkUniffi.rust_call(
        :uniffi_mdk_uniffi_fn_free_mdk,
        handle
      )
    end
  end

  # A private helper for lowering instances into a raw handle.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self.uniffi_check_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a Mdk instance, got #{inst}"
    end
  end

  def uniffi_clone_handle()
    return MdkUniffi.rust_call(
      :uniffi_mdk_uniffi_fn_clone_mdk,
      @handle
    )
  end

  def self.uniffi_lower(inst)
    return inst.uniffi_clone_handle()
  end

  

  def accept_welcome(welcome)
        welcome = welcome
        RustBuffer.check_lower_TypeWelcome(welcome)
      MdkUniffi.rust_call_with_error(MdkUniffiError,:uniffi_mdk_uniffi_fn_method_mdk_accept_welcome,uniffi_clone_handle(),RustBuffer.alloc_from_TypeWelcome(welcome))
  end
  
  def accept_welcome_json(welcome_json)
        welcome_json = MdkUniffi::uniffi_utf8(welcome_json)
        
      MdkUniffi.rust_call_with_error(MdkUniffiError,:uniffi_mdk_uniffi_fn_method_mdk_accept_welcome_json,uniffi_clone_handle(),RustBuffer.allocFromString(welcome_json))
  end
  
  def add_members(mls_group_id, key_package_events_json)
        mls_group_id = MdkUniffi::uniffi_utf8(mls_group_id)
        
        key_package_events_json = key_package_events_json.map { |v| MdkUniffi::uniffi_utf8(v) }
        RustBuffer.check_lower_Sequencestring(key_package_events_json)
    result = MdkUniffi.rust_call_with_error(MdkUniffiError,:uniffi_mdk_uniffi_fn_method_mdk_add_members,uniffi_clone_handle(),RustBuffer.allocFromString(mls_group_id),RustBuffer.alloc_from_Sequencestring(key_package_events_json))
    return result.consumeIntoTypeUpdateGroupResult
  end
  def create_group(creator_public_key, member_key_package_events_json, name, description, relays, admins)
        creator_public_key = MdkUniffi::uniffi_utf8(creator_public_key)
        
        member_key_package_events_json = member_key_package_events_json.map { |v| MdkUniffi::uniffi_utf8(v) }
        RustBuffer.check_lower_Sequencestring(member_key_package_events_json)
        name = MdkUniffi::uniffi_utf8(name)
        
        description = MdkUniffi::uniffi_utf8(description)
        
        relays = relays.map { |v| MdkUniffi::uniffi_utf8(v) }
        RustBuffer.check_lower_Sequencestring(relays)
        admins = admins.map { |v| MdkUniffi::uniffi_utf8(v) }
        RustBuffer.check_lower_Sequencestring(admins)
    result = MdkUniffi.rust_call_with_error(MdkUniffiError,:uniffi_mdk_uniffi_fn_method_mdk_create_group,uniffi_clone_handle(),RustBuffer.allocFromString(creator_public_key),RustBuffer.alloc_from_Sequencestring(member_key_package_events_json),RustBuffer.allocFromString(name),RustBuffer.allocFromString(description),RustBuffer.alloc_from_Sequencestring(relays),RustBuffer.alloc_from_Sequencestring(admins))
    return result.consumeIntoTypeCreateGroupResult
  end
  def create_key_package_for_event(public_key, relays)
        public_key = MdkUniffi::uniffi_utf8(public_key)
        
        relays = relays.map { |v| MdkUniffi::uniffi_utf8(v) }
        RustBuffer.check_lower_Sequencestring(relays)
    result = MdkUniffi.rust_call_with_error(MdkUniffiError,:uniffi_mdk_uniffi_fn_method_mdk_create_key_package_for_event,uniffi_clone_handle(),RustBuffer.allocFromString(public_key),RustBuffer.alloc_from_Sequencestring(relays))
    return result.consumeIntoTypeKeyPackageResult
  end
  def create_message(mls_group_id, sender_public_key, content, kind, tags)
        mls_group_id = MdkUniffi::uniffi_utf8(mls_group_id)
        
        sender_public_key = MdkUniffi::uniffi_utf8(sender_public_key)
        
        content = MdkUniffi::uniffi_utf8(content)
        
        kind = MdkUniffi::uniffi_in_range(kind, "u16", 0, 2**16)
        
        tags = (tags ? tags.map { |v| v.map { |v| MdkUniffi::uniffi_utf8(v) } } : nil)
        RustBuffer.check_lower_OptionalSequenceSequencestring(tags)
    result = MdkUniffi.rust_call_with_error(MdkUniffiError,:uniffi_mdk_uniffi_fn_method_mdk_create_message,uniffi_clone_handle(),RustBuffer.allocFromString(mls_group_id),RustBuffer.allocFromString(sender_public_key),RustBuffer.allocFromString(content),kind,RustBuffer.alloc_from_OptionalSequenceSequencestring(tags))
    return result.consumeIntoString
  end
  def decline_welcome(welcome)
        welcome = welcome
        RustBuffer.check_lower_TypeWelcome(welcome)
      MdkUniffi.rust_call_with_error(MdkUniffiError,:uniffi_mdk_uniffi_fn_method_mdk_decline_welcome,uniffi_clone_handle(),RustBuffer.alloc_from_TypeWelcome(welcome))
  end
  
  def decline_welcome_json(welcome_json)
        welcome_json = MdkUniffi::uniffi_utf8(welcome_json)
        
      MdkUniffi.rust_call_with_error(MdkUniffiError,:uniffi_mdk_uniffi_fn_method_mdk_decline_welcome_json,uniffi_clone_handle(),RustBuffer.allocFromString(welcome_json))
  end
  
  def get_group(mls_group_id)
        mls_group_id = MdkUniffi::uniffi_utf8(mls_group_id)
        
    result = MdkUniffi.rust_call_with_error(MdkUniffiError,:uniffi_mdk_uniffi_fn_method_mdk_get_group,uniffi_clone_handle(),RustBuffer.allocFromString(mls_group_id))
    return result.consumeIntoOptionalTypeGroup
  end
  def get_groups()
    result = MdkUniffi.rust_call_with_error(MdkUniffiError,:uniffi_mdk_uniffi_fn_method_mdk_get_groups,uniffi_clone_handle(),)
    return result.consumeIntoSequenceTypeGroup
  end
  def get_members(mls_group_id)
        mls_group_id = MdkUniffi::uniffi_utf8(mls_group_id)
        
    result = MdkUniffi.rust_call_with_error(MdkUniffiError,:uniffi_mdk_uniffi_fn_method_mdk_get_members,uniffi_clone_handle(),RustBuffer.allocFromString(mls_group_id))
    return result.consumeIntoSequencestring
  end
  def get_message(event_id)
        event_id = MdkUniffi::uniffi_utf8(event_id)
        
    result = MdkUniffi.rust_call_with_error(MdkUniffiError,:uniffi_mdk_uniffi_fn_method_mdk_get_message,uniffi_clone_handle(),RustBuffer.allocFromString(event_id))
    return result.consumeIntoOptionalTypeMessage
  end
  def get_messages(mls_group_id)
        mls_group_id = MdkUniffi::uniffi_utf8(mls_group_id)
        
    result = MdkUniffi.rust_call_with_error(MdkUniffiError,:uniffi_mdk_uniffi_fn_method_mdk_get_messages,uniffi_clone_handle(),RustBuffer.allocFromString(mls_group_id))
    return result.consumeIntoSequenceTypeMessage
  end
  def get_pending_welcomes()
    result = MdkUniffi.rust_call_with_error(MdkUniffiError,:uniffi_mdk_uniffi_fn_method_mdk_get_pending_welcomes,uniffi_clone_handle(),)
    return result.consumeIntoSequenceTypeWelcome
  end
  def get_relays(mls_group_id)
        mls_group_id = MdkUniffi::uniffi_utf8(mls_group_id)
        
    result = MdkUniffi.rust_call_with_error(MdkUniffiError,:uniffi_mdk_uniffi_fn_method_mdk_get_relays,uniffi_clone_handle(),RustBuffer.allocFromString(mls_group_id))
    return result.consumeIntoSequencestring
  end
  def get_welcome(event_id)
        event_id = MdkUniffi::uniffi_utf8(event_id)
        
    result = MdkUniffi.rust_call_with_error(MdkUniffiError,:uniffi_mdk_uniffi_fn_method_mdk_get_welcome,uniffi_clone_handle(),RustBuffer.allocFromString(event_id))
    return result.consumeIntoOptionalTypeWelcome
  end
  def leave_group(mls_group_id)
        mls_group_id = MdkUniffi::uniffi_utf8(mls_group_id)
        
    result = MdkUniffi.rust_call_with_error(MdkUniffiError,:uniffi_mdk_uniffi_fn_method_mdk_leave_group,uniffi_clone_handle(),RustBuffer.allocFromString(mls_group_id))
    return result.consumeIntoTypeUpdateGroupResult
  end
  def merge_pending_commit(mls_group_id)
        mls_group_id = MdkUniffi::uniffi_utf8(mls_group_id)
        
      MdkUniffi.rust_call_with_error(MdkUniffiError,:uniffi_mdk_uniffi_fn_method_mdk_merge_pending_commit,uniffi_clone_handle(),RustBuffer.allocFromString(mls_group_id))
  end
  
  def parse_key_package(event_json)
        event_json = MdkUniffi::uniffi_utf8(event_json)
        
    result = MdkUniffi.rust_call_with_error(MdkUniffiError,:uniffi_mdk_uniffi_fn_method_mdk_parse_key_package,uniffi_clone_handle(),RustBuffer.allocFromString(event_json))
    return result.consumeIntoString
  end
  def process_message(event_json)
        event_json = MdkUniffi::uniffi_utf8(event_json)
        
    result = MdkUniffi.rust_call_with_error(MdkUniffiError,:uniffi_mdk_uniffi_fn_method_mdk_process_message,uniffi_clone_handle(),RustBuffer.allocFromString(event_json))
    return result.consumeIntoTypeProcessMessageResult
  end
  def process_welcome(wrapper_event_id, rumor_event_json)
        wrapper_event_id = MdkUniffi::uniffi_utf8(wrapper_event_id)
        
        rumor_event_json = MdkUniffi::uniffi_utf8(rumor_event_json)
        
    result = MdkUniffi.rust_call_with_error(MdkUniffiError,:uniffi_mdk_uniffi_fn_method_mdk_process_welcome,uniffi_clone_handle(),RustBuffer.allocFromString(wrapper_event_id),RustBuffer.allocFromString(rumor_event_json))
    return result.consumeIntoTypeWelcome
  end
  def remove_members(mls_group_id, member_public_keys)
        mls_group_id = MdkUniffi::uniffi_utf8(mls_group_id)
        
        member_public_keys = member_public_keys.map { |v| MdkUniffi::uniffi_utf8(v) }
        RustBuffer.check_lower_Sequencestring(member_public_keys)
    result = MdkUniffi.rust_call_with_error(MdkUniffiError,:uniffi_mdk_uniffi_fn_method_mdk_remove_members,uniffi_clone_handle(),RustBuffer.allocFromString(mls_group_id),RustBuffer.alloc_from_Sequencestring(member_public_keys))
    return result.consumeIntoTypeUpdateGroupResult
  end
  def self_update(mls_group_id)
        mls_group_id = MdkUniffi::uniffi_utf8(mls_group_id)
        
    result = MdkUniffi.rust_call_with_error(MdkUniffiError,:uniffi_mdk_uniffi_fn_method_mdk_self_update,uniffi_clone_handle(),RustBuffer.allocFromString(mls_group_id))
    return result.consumeIntoTypeUpdateGroupResult
  end
  def sync_group_metadata_from_mls(mls_group_id)
        mls_group_id = MdkUniffi::uniffi_utf8(mls_group_id)
        
      MdkUniffi.rust_call_with_error(MdkUniffiError,:uniffi_mdk_uniffi_fn_method_mdk_sync_group_metadata_from_mls,uniffi_clone_handle(),RustBuffer.allocFromString(mls_group_id))
  end
  
  def update_group_data(mls_group_id, update)
        mls_group_id = MdkUniffi::uniffi_utf8(mls_group_id)
        
        update = update
        RustBuffer.check_lower_TypeGroupDataUpdate(update)
    result = MdkUniffi.rust_call_with_error(MdkUniffiError,:uniffi_mdk_uniffi_fn_method_mdk_update_group_data,uniffi_clone_handle(),RustBuffer.allocFromString(mls_group_id),RustBuffer.alloc_from_TypeGroupDataUpdate(update))
    return result.consumeIntoTypeUpdateGroupResult
  end
  
end
  
end

